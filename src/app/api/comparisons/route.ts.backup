import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@clerk/nextjs/server'
import { createAdminClient } from '@/lib/supabase/server'
import { comparePhotos } from '@/lib/anthropic/compare'
import { z } from 'zod'
import type { InspectionPhoto, ComparisonStatus } from '@/types/database'

/**
 * Comparisons API - VistorIA Pro
 * GET: List all comparisons for authenticated user
 * POST: Create new comparison
 */

const createComparisonSchema = z.object({
  property_id: z.string().uuid(),
  move_in_inspection_id: z.string().uuid(),
  move_out_inspection_id: z.string().uuid(),
})

// GET: List all comparisons
export async function GET(request: NextRequest) {
  try {
    const { userId } = await auth()
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const supabase = createAdminClient()

    // Get user from database
    const { data: user } = await supabase
      .from('users')
      .select('id')
      .eq('clerk_id', userId)
      .single()

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 })
    }

    // Get search params
    const searchParams = request.nextUrl.searchParams
    const propertyId = searchParams.get('property_id')
    const status = searchParams.get('status')

    // Build query
    let query = supabase
      .from('comparisons')
      .select(`
        *,
        property:properties(id, name, address),
        move_in_inspection:inspections!comparisons_move_in_inspection_id_fkey(id, type, created_at),
        move_out_inspection:inspections!comparisons_move_out_inspection_id_fkey(id, type, created_at)
      `)
      .eq('user_id', user.id)
      .order('created_at', { ascending: false })

    // Apply filters
    if (propertyId) {
      query = query.eq('property_id', propertyId)
    }

    if (status && status !== 'all') {
      query = query.eq('status', status)
    }

    const { data: comparisons, error } = await query

    if (error) {
      console.error('Error fetching comparisons:', error)
      return NextResponse.json(
        { error: 'Failed to fetch comparisons' },
        { status: 500 }
      )
    }

    return NextResponse.json({
      comparisons: comparisons || [],
      count: comparisons?.length || 0,
    })
  } catch (error) {
    console.error('Error in GET /api/comparisons:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

// POST: Create new comparison
export async function POST(request: NextRequest) {
  try {
    const { userId } = await auth()
    if (!userId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const supabase = createAdminClient()

    // Get user from database
    const { data: user } = await supabase
      .from('users')
      .select('id, credits, email')
      .eq('clerk_id', userId)
      .single()

    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 })
    }

    // Verificar créditos (1 crédito necessário)
    if (user.credits < 1) {
      return NextResponse.json(
        { error: 'Créditos insuficientes. Compre mais créditos para criar comparações.' },
        { status: 402 }
      )
    }

    // Parse and validate request body
    const body = await request.json()
    const validatedData = createComparisonSchema.parse(body)

    // Verificar que a propriedade pertence ao usuário
    const { data: property } = await supabase
      .from('properties')
      .select('id')
      .eq('id', validatedData.property_id)
      .eq('user_id', user.id)
      .is('deleted_at', null)
      .single()

    if (!property) {
      return NextResponse.json(
        { error: 'Propriedade não encontrada' },
        { status: 404 }
      )
    }

    // Buscar as duas vistorias
    const { data: inspections } = await supabase
      .from('inspections')
      .select('id, type, property_id')
      .in('id', [validatedData.move_in_inspection_id, validatedData.move_out_inspection_id])
      .eq('user_id', user.id)
      .is('deleted_at', null)

    if (!inspections || inspections.length !== 2) {
      return NextResponse.json(
        { error: 'Uma ou ambas as vistorias não foram encontradas' },
        { status: 404 }
      )
    }

    // Validar que são do mesmo imóvel
    const allSameProperty = inspections.every(
      (insp) => insp.property_id === validatedData.property_id
    )
    if (!allSameProperty) {
      return NextResponse.json(
        { error: 'As vistorias devem ser do mesmo imóvel' },
        { status: 400 }
      )
    }

    // Validar que uma é move_in e outra move_out
    const types = inspections.map((insp) => insp.type)
    if (!types.includes('move_in') || !types.includes('move_out')) {
      return NextResponse.json(
        { error: 'É necessário uma vistoria de entrada e uma de saída' },
        { status: 400 }
      )
    }

    // Verificar se já existe comparação para essas vistorias
    const { data: existingComparison } = await supabase
      .from('comparisons')
      .select('id')
      .eq('move_in_inspection_id', validatedData.move_in_inspection_id)
      .eq('move_out_inspection_id', validatedData.move_out_inspection_id)
      .single()

    if (existingComparison) {
      return NextResponse.json(
        { error: 'Já existe uma comparação para essas vistorias' },
        { status: 409 }
      )
    }

    // Criar registro de comparação com status 'processing'
    const { data: comparison, error: comparisonError } = await supabase
      .from('comparisons')
      .insert({
        user_id: user.id,
        property_id: validatedData.property_id,
        move_in_inspection_id: validatedData.move_in_inspection_id,
        move_out_inspection_id: validatedData.move_out_inspection_id,
        status: 'processing' as ComparisonStatus,
      })
      .select()
      .single()

    if (comparisonError || !comparison) {
      console.error('Error creating comparison:', comparisonError)
      return NextResponse.json(
        { error: 'Falha ao criar comparação' },
        { status: 500 }
      )
    }

    // Processar comparação em background (async)
    processComparison(comparison.id, validatedData, user.id, user.credits)
      .catch((error) => {
        console.error('Error processing comparison:', error)
      })

    return NextResponse.json(
      {
        comparison,
        message: 'Comparação criada com sucesso. O processamento está em andamento.',
      },
      { status: 201 }
    )
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation error', details: error.issues },
        { status: 400 }
      )
    }

    console.error('Error in POST /api/comparisons:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}

/**
 * Processa a comparação em background
 * Compara fotos, detecta diferenças, calcula custos
 */
async function processComparison(
  comparisonId: string,
  data: z.infer<typeof createComparisonSchema>,
  userId: string,
  currentCredits: number
) {
  const supabase = createAdminClient()

  try {
    // Buscar todas as fotos de ambas as vistorias
    const { data: moveInPhotos } = await supabase
      .from('inspection_photos')
      .select('*')
      .eq('inspection_id', data.move_in_inspection_id)
      .is('deleted_at', null)
      .order('room_name')

    const { data: moveOutPhotos } = await supabase
      .from('inspection_photos')
      .select('*')
      .eq('inspection_id', data.move_out_inspection_id)
      .is('deleted_at', null)
      .order('room_name')

    if (!moveInPhotos || !moveOutPhotos) {
      throw new Error('Fotos não encontradas')
    }

    // Agrupar fotos por cômodo
    const photosByRoom = matchPhotosByRoom(moveInPhotos, moveOutPhotos)

    let totalDifferences = 0
    let totalNewDamages = 0
    let totalCost = 0

    // Processar cada par de fotos
    for (const { roomName, beforePhotos, afterPhotos } of photosByRoom) {
      // Comparar primeira foto de cada cômodo (por simplicidade)
      // Em produção, você pode comparar múltiplas fotos
      if (beforePhotos.length > 0 && afterPhotos.length > 0) {
        const beforePhoto = beforePhotos[0]
        const afterPhoto = afterPhotos[0]

        // Obter URLs públicas
        const beforeUrl = supabase.storage
          .from('inspection-photos')
          .getPublicUrl(beforePhoto.storage_path).data.publicUrl

        const afterUrl = supabase.storage
          .from('inspection-photos')
          .getPublicUrl(afterPhoto.storage_path).data.publicUrl

        // Comparar com IA
        const analysisResult = await comparePhotos(beforeUrl, afterUrl, roomName)

        // Salvar diferenças
        if (analysisResult.hasDifference && analysisResult.differences.length > 0) {
          for (const diff of analysisResult.differences) {
            await supabase.from('comparison_differences').insert({
              comparison_id: comparisonId,
              before_photo_id: beforePhoto.id,
              after_photo_id: afterPhoto.id,
              room_name: roomName,
              description: diff.description,
              severity: diff.severity,
              is_new_damage: diff.isNewDamage,
              is_natural_wear: diff.isNaturalWear,
              estimated_repair_cost: diff.estimatedCost,
              markers: { location: diff.location },
            })

            totalDifferences++
            if (diff.isNewDamage) {
              totalNewDamages++
              totalCost += diff.estimatedCost
            }
          }
        }
      }
    }

    // Atualizar comparação com resultados
    await supabase
      .from('comparisons')
      .update({
        status: 'completed' as ComparisonStatus,
        differences_detected: totalDifferences,
        new_damages: totalNewDamages,
        estimated_repair_cost: totalCost,
        updated_at: new Date().toISOString(),
      })
      .eq('id', comparisonId)

    // Deduzir 1 crédito
    const newCredits = currentCredits - 1
    await supabase
      .from('users')
      .update({ credits: newCredits })
      .eq('id', userId)

    // Registrar uso de crédito
    await supabase.from('credit_usage').insert({
      user_id: userId,
      comparison_id: comparisonId,
      credits_used: 1,
      credits_before: currentCredits,
      credits_after: newCredits,
      reason: 'Comparação de vistorias',
    })

    console.log(`Comparison ${comparisonId} processed successfully`)
  } catch (error) {
    console.error('Error processing comparison:', error)

    // Marcar como failed
    await supabase
      .from('comparisons')
      .update({
        status: 'failed' as ComparisonStatus,
        updated_at: new Date().toISOString(),
      })
      .eq('id', comparisonId)
  }
}

/**
 * Agrupa fotos por cômodo para comparação
 */
function matchPhotosByRoom(
  moveInPhotos: InspectionPhoto[],
  moveOutPhotos: InspectionPhoto[]
): Array<{
  roomName: string
  beforePhotos: InspectionPhoto[]
  afterPhotos: InspectionPhoto[]
}> {
  const roomMap = new Map<
    string,
    { beforePhotos: InspectionPhoto[]; afterPhotos: InspectionPhoto[] }
  >()

  // Agrupar fotos de entrada
  for (const photo of moveInPhotos) {
    const roomName = photo.room_name
    if (!roomMap.has(roomName)) {
      roomMap.set(roomName, { beforePhotos: [], afterPhotos: [] })
    }
    roomMap.get(roomName)!.beforePhotos.push(photo)
  }

  // Agrupar fotos de saída
  for (const photo of moveOutPhotos) {
    const roomName = photo.room_name
    if (!roomMap.has(roomName)) {
      roomMap.set(roomName, { beforePhotos: [], afterPhotos: [] })
    }
    roomMap.get(roomName)!.afterPhotos.push(photo)
  }

  // Converter para array
  return Array.from(roomMap.entries()).map(([roomName, photos]) => ({
    roomName,
    beforePhotos: photos.beforePhotos,
    afterPhotos: photos.afterPhotos,
  }))
}
